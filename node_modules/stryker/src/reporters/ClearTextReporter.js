"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chalk = require("chalk");
var log4js = require("log4js");
var report_1 = require("stryker-api/report");
var log = log4js.getLogger('ClearTextReporter');
var ClearTextReporter = (function () {
    function ClearTextReporter(options) {
        this.options = options;
        this.out = process.stdout;
    }
    ClearTextReporter.prototype.writeLine = function (output) {
        this.out.write((output || '') + "\n");
    };
    ClearTextReporter.prototype.onAllMutantsTested = function (mutantResults) {
        var _this = this;
        this.writeLine();
        var totalTests = 0;
        var mutantsKilled = 0;
        var mutantsTimedOut = 0;
        var mutantsNoCoverage = 0;
        var mutantsSurvived = 0;
        var mutantsErrored = 0;
        // use these fn's in order to preserve the 'this` pointer
        var logDebugFn = function (input) { return log.debug(input); };
        var writeLineFn = function (input) { return _this.writeLine(input); };
        mutantResults.forEach(function (result) {
            if (result.testsRan) {
                totalTests += result.testsRan.length;
            }
            switch (result.status) {
                case report_1.MutantStatus.Killed:
                    mutantsKilled++;
                    log.debug(chalk.bold.green('Mutant killed!'));
                    _this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.TimedOut:
                    mutantsTimedOut++;
                    log.debug(chalk.bold.yellow('Mutant timed out!'));
                    _this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.Error:
                    mutantsErrored++;
                    log.debug(chalk.bold.yellow('Mutant caused an error!'));
                    _this.logMutantResult(result, logDebugFn);
                    break;
                case report_1.MutantStatus.Survived:
                    mutantsSurvived++;
                    _this.writeLine(chalk.bold.red('Mutant survived!'));
                    _this.logMutantResult(result, writeLineFn);
                    break;
                case report_1.MutantStatus.NoCoverage:
                    mutantsNoCoverage++;
                    _this.writeLine(chalk.bold.yellow('Mutant survived! (no coverage)'));
                    _this.logMutantResult(result, writeLineFn);
                    break;
            }
        });
        var mutantsWithoutErrors = mutantResults.length - mutantsErrored;
        var mutationScoreCodebase = (((mutantsKilled + mutantsTimedOut) / mutantsWithoutErrors) * 100).toFixed(2);
        var mutationScoreCodeCoverage = (((mutantsKilled + mutantsTimedOut) / ((mutantsWithoutErrors - mutantsNoCoverage) || 1)) * 100).toFixed(2);
        var codebaseColor = this.getColorForMutationScore(+mutationScoreCodebase);
        var codecoverageColor = this.getColorForMutationScore(+mutationScoreCodeCoverage);
        this.writeLine(mutantResults.length + " total mutants.");
        this.writeLine((mutantsSurvived + mutantsNoCoverage) + ' mutants survived.');
        if (mutantsNoCoverage > 0) {
            this.writeLine("  of which " + mutantsNoCoverage + " were not covered by the tests.");
        }
        if (mutantsErrored > 0) {
            this.writeLine(mutantsErrored + ' mutant(s) caused an error and were therefore not accounted for in the mutation score.');
        }
        this.writeLine(mutantsTimedOut + ' mutants timed out.');
        this.writeLine(mutantsKilled + ' mutants killed.');
        this.writeLine("Ran " + (totalTests / mutantResults.length).toFixed(2) + " tests per mutant on average.");
        if (this.options.coverageAnalysis === 'off') {
            this.writeLine("Mutation score based on covered code: n/a");
        }
        else {
            this.writeLine("Mutation score based on covered code: " + codecoverageColor(mutationScoreCodeCoverage + '%'));
        }
        this.writeLine("Mutation score based on all code: " + codebaseColor(mutationScoreCodebase + '%'));
    };
    ClearTextReporter.prototype.logMutantResult = function (result, logImplementation) {
        logImplementation(result.sourceFilePath + ': line ' + result.location.start.line + ':' + result.location.start.column);
        logImplementation('Mutator: ' + result.mutatorName);
        result.originalLines.split('\n').forEach(function (line) {
            logImplementation(chalk.red('-   ' + line));
        });
        result.mutatedLines.split('\n').forEach(function (line) {
            logImplementation(chalk.green('+   ' + line));
        });
        logImplementation('');
        if (this.options.coverageAnalysis === 'perTest') {
            this.logExecutedTests(result, logImplementation);
        }
        else if (result.testsRan && result.testsRan.length > 0) {
            logImplementation('Ran all tests for this mutant.');
        }
    };
    ClearTextReporter.prototype.logExecutedTests = function (result, logImplementation) {
        var clearTextReporterConfig = this.options['clearTextReporter'];
        if (result.testsRan && result.testsRan.length > 0) {
            var testsToLog = 3;
            if (clearTextReporterConfig && typeof clearTextReporterConfig.maxTestsToLog === 'number') {
                testsToLog = clearTextReporterConfig.maxTestsToLog;
            }
            if (testsToLog > 0) {
                logImplementation('Tests ran: ');
                for (var i = 0; i < testsToLog; i++) {
                    if (i > result.testsRan.length - 1) {
                        break;
                    }
                    logImplementation('    ' + result.testsRan[i]);
                }
                if (testsToLog < result.testsRan.length) {
                    logImplementation("  and " + (result.testsRan.length - testsToLog) + " more tests!");
                }
                logImplementation('');
            }
        }
    };
    /**
     * Gets the color associated with a mutation score.
     * @function
     * @param score - The mutation score.
     * @returns {Function} The function which can give the mutation score the right color.
     */
    ClearTextReporter.prototype.getColorForMutationScore = function (score) {
        var color;
        if (score > 80) {
            color = chalk.green;
        }
        else if (score > 50) {
            color = chalk.yellow;
        }
        else {
            color = chalk.red;
        }
        return color;
    };
    return ClearTextReporter;
}());
exports.default = ClearTextReporter;
//# sourceMappingURL=ClearTextReporter.js.map