"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path = require("path");
var fs = require("graceful-fs");
var _ = require("lodash");
var nodeGlob = require("glob");
var mkdirp = require("mkdirp");
/**
 * Checks if a file or folder exists.
 * @function
 * @param path - The path to the file or folder.
 * @returns True if the file exists.
 */
function fileOrFolderExistsSync(path) {
    try {
        fs.lstatSync(path);
        return true;
    }
    catch (error) {
        return false;
    }
}
exports.fileOrFolderExistsSync = fileOrFolderExistsSync;
;
function fileOrFolderExists(path) {
    return new Promise(function (resolve) {
        fs.lstat(path, function (error, stats) {
            resolve(!error);
        });
    });
}
exports.fileOrFolderExists = fileOrFolderExists;
/**
 * Reads a file.
 * @function
 * @param filename - The name of the file.
 * @returns The content of the file.
 */
function readFile(filename) {
    return fs.readFileSync(filename, 'utf8');
}
exports.readFile = readFile;
;
/**
   * Normalizes the paths of a list of filenames.
   * @param files - The list of filenames which have to be normalized.
   */
function normalize(files) {
    _.forEach(files, function (file, key) {
        files[key] = path.resolve(path.normalize(file));
    });
}
exports.normalize = normalize;
;
function glob(expression) {
    return new Promise(function (resolve, reject) {
        nodeGlob(expression, { nodir: true }, function (error, matches) {
            if (error) {
                reject(error);
            }
            else {
                resolve(matches);
            }
        });
    });
}
exports.glob = glob;
function readdir(path) {
    return new Promise(function (resolve, reject) {
        fs.readdir(path, function (error, files) {
            if (error) {
                reject(error);
            }
            else {
                resolve(files);
            }
        });
    });
}
exports.readdir = readdir;
function stats(path) {
    return new Promise(function (resolve, reject) {
        fs.stat(path, function (error, stats) {
            if (error) {
                reject(error);
            }
            else {
                resolve(stats);
            }
        });
    });
}
function rmFile(path) {
    return new Promise(function (fileResolve, fileReject) {
        fs.unlink(path, function (error) {
            if (error) {
                fileReject(error);
            }
            else {
                fileResolve();
            }
        });
    });
}
function rmdir(dirToDelete) {
    return new Promise(function (resolve, reject) {
        fs.rmdir(dirToDelete, function (error) {
            if (error) {
                reject(error);
            }
            else {
                resolve();
            }
        });
    });
}
/**
 * Deletes a directory recursively
 */
function deleteDir(dirToDelete) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var _this = this;
        var exists, files, promisses;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fileOrFolderExists(dirToDelete)];
                case 1:
                    exists = _a.sent();
                    if (!exists) return [3 /*break*/, 4];
                    return [4 /*yield*/, readdir(dirToDelete)];
                case 2:
                    files = _a.sent();
                    promisses = files.map(function (file) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                        var currentPath, sts;
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    currentPath = path.join(dirToDelete, file);
                                    return [4 /*yield*/, stats(currentPath)];
                                case 1:
                                    sts = _a.sent();
                                    if (sts.isDirectory()) {
                                        // recursive
                                        return [2 /*return*/, deleteDir(currentPath)];
                                    }
                                    else {
                                        // delete file
                                        return [2 /*return*/, rmFile(currentPath)];
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); });
                    // delete dir
                    return [4 /*yield*/, Promise.all(promisses)];
                case 3:
                    // delete dir
                    _a.sent();
                    return [2 /*return*/, rmdir(dirToDelete)];
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.deleteDir = deleteDir;
function cleanFolder(folderName) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var exists;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fileOrFolderExists(folderName)];
                case 1:
                    exists = _a.sent();
                    if (!exists) return [3 /*break*/, 3];
                    return [4 /*yield*/, deleteDir(folderName)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, mkdirRecursive(folderName)];
                case 3: return [2 /*return*/, mkdirRecursive(folderName)];
                case 4:
                    ;
                    return [2 /*return*/];
            }
        });
    });
}
exports.cleanFolder = cleanFolder;
function writeFile(fileName, content) {
    return new Promise(function (resolve, reject) {
        fs.writeFile(fileName, content, function (err) {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.writeFile = writeFile;
function mkdirRecursive(folderName) {
    if (!fileOrFolderExistsSync(folderName)) {
        mkdirp.sync(folderName);
    }
}
exports.mkdirRecursive = mkdirRecursive;
/**
 * Wrapper around the 'require' function (for testability)
 */
function importModule(moduleName) {
    require(moduleName);
}
exports.importModule = importModule;
function isOnlineFile(path) {
    return path.indexOf('http://') === 0 || path.indexOf('https://') === 0;
}
exports.isOnlineFile = isOnlineFile;
//# sourceMappingURL=fileUtils.js.map