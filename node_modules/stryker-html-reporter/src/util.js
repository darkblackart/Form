"use strict";
var mzfs = require('mz/fs');
var path = require('path');
var handlebars = require('handlebars');
var _ = require('lodash');
var mkdirp = require('mkdirp');
var report_1 = require('stryker-api/report');
function copyFolder(fromPath, to) {
    return mkdirRecursive(to).then(function () { return mzfs.readdir(fromPath).then(function (files) {
        var promisses = [];
        files.forEach(function (file) {
            var currentPath = path.join(fromPath, file);
            var toCurrentPath = path.join(to, file);
            promisses.push(mzfs.stat(currentPath).then(function (stats) {
                if (stats.isDirectory()) {
                    return copyFolder(currentPath, toCurrentPath);
                }
                else {
                    return copyFile(currentPath, toCurrentPath);
                }
            }));
        });
        return Promise.all(promisses);
    }); });
}
exports.copyFolder = copyFolder;
function copyFile(fromFilename, toFilename) {
    return new Promise(function (resolve, reject) {
        var readStream = mzfs.createReadStream(fromFilename);
        var writeStream = mzfs.createWriteStream(toFilename);
        readStream.on('error', reject);
        writeStream.on('error', reject);
        readStream.pipe(writeStream);
        readStream.on('end', function () { return resolve(); });
    });
}
exports.copyFile = copyFile;
function rmFile(path) {
    return mzfs.unlink(path);
}
function deleteDir(dirToDelete) {
    return fileOrFolderExists(dirToDelete).then(function (exists) {
        if (exists) {
            return mzfs.readdir(dirToDelete).then(function (files) {
                var promisses = files.map(function (file) {
                    var currentPath = path.join(dirToDelete, file);
                    return mzfs.stat(currentPath).then(function (stats) {
                        if (stats.isDirectory()) {
                            // recursive
                            return deleteDir(currentPath);
                        }
                        else {
                            // delete file
                            return rmFile(currentPath);
                        }
                    });
                });
                // delete dir
                return Promise.all(promisses).then(function () { return mzfs.rmdir(dirToDelete); });
            });
        }
    });
}
exports.deleteDir = deleteDir;
function mkdirRecursiveSync(folderName) {
    mkdirp.sync(folderName);
}
exports.mkdirRecursiveSync = mkdirRecursiveSync;
function mkdirRecursive(folderName) {
    return new Promise(function (resolve, reject) {
        mkdirp(folderName, function (err) {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
exports.mkdirRecursive = mkdirRecursive;
function fileOrFolderExists(path) {
    return new Promise(function (resolve) {
        mzfs.lstat(path, function (error, stats) {
            resolve(!error);
        });
    });
}
function readTemplate(name) {
    return mzfs.readFileSync(path.join(__dirname, 'templates', name + ".tpl.html"), 'utf8');
}
function compileTemplate(name) {
    return handlebars.compile(readTemplate(name));
}
var templates = {
    node: compileTemplate('node'),
    footer: compileTemplate('footer'),
    header: compileTemplate('header'),
    sourceFile: compileTemplate('sourceFile'),
};
handlebars.registerPartial('resultRow', readTemplate('resultRow'));
handlebars.registerPartial('resultTableHead', readTemplate('resultTableHead'));
handlebars.registerHelper('code', function () {
    var leaf = this;
    var currentBackground = null;
    var currentCursorMutantStatusses = {
        killed: 0,
        survived: 0,
        timeout: 0,
        noCoverage: 0
    };
    var maxIndex = leaf.file.content.length - 1;
    var numberedMutants = _.sortBy(leaf.results, function (m) { return m.range[0] * 10000 + m.range[1] * -1; })
        .map(function (mutant, index) { return ({ mutant: mutant, index: index }); });
    var adjustCurrentMutantResult = function (valueToAdd) { return function (numberedMutant) {
        switch (numberedMutant.mutant.status) {
            case report_1.MutantStatus.Killed:
                currentCursorMutantStatusses.killed += valueToAdd;
                break;
            case report_1.MutantStatus.Survived:
                currentCursorMutantStatusses.survived += valueToAdd;
                break;
            case report_1.MutantStatus.TimedOut:
                currentCursorMutantStatusses.timeout += valueToAdd;
                break;
            case report_1.MutantStatus.NoCoverage:
                currentCursorMutantStatusses.noCoverage += valueToAdd;
                break;
        }
    }; };
    var determineBackground = function () {
        if (currentCursorMutantStatusses.survived > 0) {
            return getContextClassForStatus(report_1.MutantStatus.Survived);
        }
        else if (currentCursorMutantStatusses.noCoverage > 0) {
            return getContextClassForStatus(report_1.MutantStatus.NoCoverage);
        }
        else if (currentCursorMutantStatusses.timeout > 0) {
            return getContextClassForStatus(report_1.MutantStatus.TimedOut);
        }
        else if (currentCursorMutantStatusses.killed > 0) {
            return getContextClassForStatus(report_1.MutantStatus.Killed);
        }
        return null;
    };
    var annotate = function (char, index) {
        var mutantsStarting = numberedMutants.filter(function (m) { return m.mutant.range[0] === index; });
        var mutantsEnding = numberedMutants.filter(function (m) { return m.mutant.range[1] === index; });
        mutantsStarting.forEach(adjustCurrentMutantResult(1));
        mutantsEnding.forEach(adjustCurrentMutantResult(-1));
        var backgroundColorAnnotation = mutantsStarting.length || mutantsEnding.length || index === 0 ? "<span class=\"bg-" + determineBackground() + "\">" : '';
        var backgroundColorEndAnnotation = ((mutantsStarting.length || mutantsEnding.length) && index > 0) || index === maxIndex ? '</span>' : '';
        var mutantsAnnotations = mutantsStarting.map(function (m) {
            return ("<a href=\"#\" class=\"stryker-mutant-button\" data-mutant-status-annotation=\"" + getContextClassForStatus(m.mutant.status) + "\" data-mutant=\"" + m.index + "\">") +
                ("<span class=\"label label-" + getContextClassForStatus(m.mutant.status) + "\">" + m.index + "</span>") +
                "</a>"
                + ("<span class=\"label label-info stryker-mutant-replacement\" hidden data-mutant=\"" + m.index + "\">" + escape(m.mutant.replacement) + "</span>");
        });
        var originalCodeStartAnnotations = mutantsStarting.map(function (m) { return ("<span class=\"stryker-original-code\" data-mutant=\"" + m.index + "\">"); });
        var originalCodeEndAnnotations = mutantsEnding.map(function (m) { return '</span>'; });
        var mutantReplacements = mutantsEnding.map(function (m) { return ("<span class=\"label label-info stryker-mutant-replacement\" hidden data-mutant=\"" + m.index + "\">" + escape(m.mutant.replacement) + "</span>"); });
        return "" + backgroundColorEndAnnotation + originalCodeEndAnnotations.join('') + mutantsAnnotations.join('') + originalCodeStartAnnotations.join('') + backgroundColorAnnotation + escape(char);
    };
    return new handlebars.SafeString("<pre><code class=\"lang-javascript\">" + mapString(leaf.file.content, annotate).join('') + "</code></pre>");
});
function getContextClassForStatus(status) {
    switch (status) {
        case report_1.MutantStatus.Killed:
            return 'success';
        case report_1.MutantStatus.NoCoverage:
        case report_1.MutantStatus.Survived:
            return 'danger';
        case report_1.MutantStatus.TimedOut:
            return 'warning';
    }
}
function escape(input) {
    return handlebars.escapeExpression(input);
}
/**
 * A `map` function, as in [1, 2].map(i => i+1), but for a string
 */
function mapString(source, fn) {
    var results = [];
    for (var i = 0; i < source.length; i++) {
        results.push(fn(source[i], i));
    }
    return results;
}
function nodeTemplate(context) {
    return templates.header(context) + templates.node(context) + templates.footer(context);
}
exports.nodeTemplate = nodeTemplate;
function sourceFileTemplate(context) {
    return templates.header(context) + templates.sourceFile(context) + templates.footer(context);
}
exports.sourceFileTemplate = sourceFileTemplate;
//# sourceMappingURL=util.js.map