'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var MutatorOrchestrator_1 = require("./MutatorOrchestrator");
var config_1 = require("stryker-api/config");
var SandboxCoordinator_1 = require("./SandboxCoordinator");
var ReporterOrchestrator_1 = require("./ReporterOrchestrator");
var test_runner_1 = require("stryker-api/test_runner");
var TestFrameworkOrchestrator_1 = require("./TestFrameworkOrchestrator");
var MutantTestMatcher_1 = require("./MutantTestMatcher");
var InputFileResolver_1 = require("./InputFileResolver");
var ConfigReader_1 = require("./ConfigReader");
var PluginLoader_1 = require("./PluginLoader");
var CoverageInstrumenter_1 = require("./coverage/CoverageInstrumenter");
var objectUtils_1 = require("./utils/objectUtils");
var StrykerTempFolder_1 = require("./utils/StrykerTempFolder");
var log4js = require("log4js");
var Timer_1 = require("./utils/Timer");
var log = log4js.getLogger('Stryker');
var humanReadableTestState = function (testState) {
    switch (testState) {
        case test_runner_1.TestStatus.Success:
            return 'SUCCESS';
        case test_runner_1.TestStatus.Failed:
            return 'FAILED';
        case test_runner_1.TestStatus.Skipped:
            return 'SKIPPED';
    }
};
var Stryker = (function () {
    /**
     * The Stryker mutation tester.
     * @constructor
     * @param {String[]} mutateFilePatterns - A comma seperated list of globbing expression used for selecting the files that should be mutated
     * @param {String[]} allFilePatterns - A comma seperated list of globbing expression used for selecting all files needed to run the tests. These include library files, test files and files to mutate, but should NOT include test framework files (for example jasmine)
     * @param {Object} [options] - Optional options.
     */
    function Stryker(options) {
        this.timer = new Timer_1.default();
        var configReader = new ConfigReader_1.default(options);
        this.config = configReader.readConfig();
        this.setGlobalLogLevel(); // loglevel could be changed
        this.loadPlugins();
        this.applyConfigWriters();
        this.setGlobalLogLevel(); // loglevel could be changed
        this.freezeConfig();
        this.reporter = new ReporterOrchestrator_1.default(this.config).createBroadcastReporter();
        this.testFramework = new TestFrameworkOrchestrator_1.default(this.config).determineTestFramework();
        this.coverageInstrumenter = new CoverageInstrumenter_1.default(this.config.coverageAnalysis, this.testFramework);
        this.verify();
    }
    /**
     * Runs mutation testing. This may take a while.
     * @function
     */
    Stryker.prototype.runMutationTest = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var inputFiles, _a, runResult, sandboxCoordinator, mutantResults;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.timer.reset();
                        return [4 /*yield*/, new InputFileResolver_1.default(this.config.mutate, this.config.files).resolve()];
                    case 1:
                        inputFiles = _b.sent();
                        return [4 /*yield*/, this.initialTestRun(inputFiles)];
                    case 2:
                        _a = _b.sent(), runResult = _a.runResult, sandboxCoordinator = _a.sandboxCoordinator;
                        if (!(runResult && inputFiles && sandboxCoordinator)) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.generateAndRunMutations(inputFiles, runResult, sandboxCoordinator)];
                    case 3:
                        mutantResults = _b.sent();
                        return [4 /*yield*/, this.wrapUpReporter()];
                    case 4:
                        _b.sent();
                        return [4 /*yield*/, StrykerTempFolder_1.default.clean()];
                    case 5:
                        _b.sent();
                        return [4 /*yield*/, this.logDone()];
                    case 6:
                        _b.sent();
                        return [2 /*return*/, mutantResults];
                    case 7: throw new Error('Resulting object did not contain runResult, inputFiles or sandboxCoordinator');
                }
            });
        });
    };
    Stryker.prototype.filterOutFailedTests = function (runResult) {
        return runResult.tests.filter(function (testResult) { return testResult.status === test_runner_1.TestStatus.Failed; });
    };
    Stryker.prototype.loadPlugins = function () {
        if (this.config.plugins) {
            new PluginLoader_1.default(this.config.plugins).load();
        }
    };
    Stryker.prototype.verify = function () {
        if (this.config.coverageAnalysis === 'perTest' && !this.testFramework) {
            log.fatal('Configured coverage analysis "perTest" requires there to be a testFramework configured. Either configure a testFramework or set coverageAnalysis to "all" or "off".');
            process.exit(1);
        }
    };
    Stryker.prototype.initialTestRun = function (inputFiles) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var sandboxCoordinator, runResult, failedTests;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sandboxCoordinator = new SandboxCoordinator_1.default(this.config, inputFiles, this.testFramework, this.reporter);
                        return [4 /*yield*/, sandboxCoordinator.initialRun(this.coverageInstrumenter)];
                    case 1:
                        runResult = _a.sent();
                        switch (runResult.status) {
                            case test_runner_1.RunStatus.Complete:
                                failedTests = this.filterOutFailedTests(runResult);
                                if (failedTests.length) {
                                    this.logFailedTestsInInitialRun(failedTests);
                                    throw new Error('There were failed tests in the initial test run:');
                                }
                                else {
                                    this.logInitialTestRunSucceeded(runResult.tests);
                                    return [2 /*return*/, { runResult: runResult, sandboxCoordinator: sandboxCoordinator }];
                                }
                            case test_runner_1.RunStatus.Error:
                                this.logErrorredInitialRun(runResult);
                                break;
                            case test_runner_1.RunStatus.Timeout:
                                this.logTimeoutInitialRun(runResult);
                                break;
                        }
                        ;
                        throw new Error('Something went wrong in the initial test run');
                }
            });
        });
    };
    Stryker.prototype.generateAndRunMutations = function (inputFiles, initialRunResult, sandboxCoordinator) {
        var mutants = this.generateMutants(inputFiles, initialRunResult);
        if (mutants.length) {
            return sandboxCoordinator.runMutants(mutants);
        }
        else {
            log.info('It\'s a mutant-free world, nothing to test.');
            return Promise.resolve([]);
        }
    };
    Stryker.prototype.generateMutants = function (inputFiles, runResult) {
        var mutatorOrchestrator = new MutatorOrchestrator_1.default(this.reporter);
        var mutants = mutatorOrchestrator.generateMutants(inputFiles
            .filter(function (inputFile) { return inputFile.mutated; })
            .map(function (file) { return file.path; }));
        log.info(mutants.length + " Mutant(s) generated");
        var mutantRunResultMatcher = new MutantTestMatcher_1.default(mutants, runResult, this.coverageInstrumenter.retrieveStatementMapsPerFile(), this.config, this.reporter);
        mutantRunResultMatcher.matchWithMutants();
        return mutants;
    };
    Stryker.prototype.wrapUpReporter = function () {
        var maybePromise = this.reporter.wrapUp();
        if (objectUtils_1.isPromise(maybePromise)) {
            return maybePromise;
        }
        else {
            return Promise.resolve();
        }
    };
    Stryker.prototype.applyConfigWriters = function () {
        var _this = this;
        config_1.ConfigWriterFactory.instance().knownNames().forEach(function (configWriterName) {
            config_1.ConfigWriterFactory.instance().create(configWriterName, undefined).write(_this.config);
        });
    };
    Stryker.prototype.freezeConfig = function () {
        objectUtils_1.freezeRecursively(this.config);
        if (log.isDebugEnabled()) {
            log.debug("Using config: " + JSON.stringify(this.config));
        }
    };
    Stryker.prototype.logInitialTestRunSucceeded = function (tests) {
        log.info('Initial test run succeeded. Ran %s tests in %s.', tests.length, this.timer.humanReadableElapsed());
    };
    Stryker.prototype.logDone = function () {
        log.info('Done in %s.', this.timer.humanReadableElapsed());
    };
    Stryker.prototype.setGlobalLogLevel = function () {
        log4js.setGlobalLogLevel(this.config.logLevel);
    };
    Stryker.prototype.logFailedTestsInInitialRun = function (failedTests) {
        var message = 'One or more tests failed in the initial test run:';
        failedTests.forEach(function (test) {
            message += "\n\t" + test.name;
            if (test.failureMessages && test.failureMessages.length) {
                message += "\n\t" + test.failureMessages.join('\n\t');
            }
        });
        log.error(message);
    };
    Stryker.prototype.logErrorredInitialRun = function (runResult) {
        var message = 'One or more tests errored in the initial test run:';
        if (runResult.errorMessages && runResult.errorMessages.length) {
            runResult.errorMessages.forEach(function (error) { return message += "\n\t" + error; });
        }
        log.error(message);
    };
    Stryker.prototype.logTimeoutInitialRun = function (runResult) {
        var message = 'Initial run timed out! Ran following tests before timeout:';
        runResult.tests.forEach(function (test) { return "\n\t" + test.name + " " + humanReadableTestState(test.status); });
        log.error(message);
    };
    return Stryker;
}());
exports.default = Stryker;
//# sourceMappingURL=Stryker.js.map